{"version":3,"sources":["webpack://miniProgramRC/webpack/universalModuleDefinition","webpack://miniProgramRC/webpack/bootstrap","webpack://miniProgramRC/./src/event/event.ts","webpack://miniProgramRC/./src/geom/displayProps.ts","webpack://miniProgramRC/./src/geom/matrix2d.js","webpack://miniProgramRC/./src/geom/rectangle.ts","webpack://miniProgramRC/./src/index.ts","webpack://miniProgramRC/./src/node/bitmap.ts","webpack://miniProgramRC/./src/node/graphics.ts","webpack://miniProgramRC/./src/node/group.ts","webpack://miniProgramRC/./src/node/node.ts","webpack://miniProgramRC/./src/node/shape/arrow-path.ts","webpack://miniProgramRC/./src/node/shape/circle.ts","webpack://miniProgramRC/./src/node/shape/ellipse.ts","webpack://miniProgramRC/./src/node/shape/equilateral-polygon.ts","webpack://miniProgramRC/./src/node/shape/polygon.ts","webpack://miniProgramRC/./src/node/shape/rect.ts","webpack://miniProgramRC/./src/node/shape/rounded-rect.ts","webpack://miniProgramRC/./src/node/shape/sector.ts","webpack://miniProgramRC/./src/node/shape/shape.ts","webpack://miniProgramRC/./src/node/stage.ts","webpack://miniProgramRC/./src/node/text.ts","webpack://miniProgramRC/./src/render/index.ts","webpack://miniProgramRC/./src/utils/lru.ts","webpack://miniProgramRC/./src/utils/uid.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClCa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D,mCAAmC,mBAAO,CAAC,0CAAY;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1CA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wDAAwD,uDAAuD;AAC/G,kBAAkB,uCAAuC,YAAY;AACrE;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEe,uEAAQ,EAAC;;;;;;;;;;;;;AC7hBX;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClDa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D,gCAAgC,mBAAO,CAAC,6CAAgB;AACxD,gCAAgC,mBAAO,CAAC,yCAAc;AACtD,gCAAgC,mBAAO,CAAC,yCAAc;AACtD,iCAAiC,mBAAO,CAAC,2CAAe;AACxD,+BAA+B,mBAAO,CAAC,uCAAa;AACpD,mCAAmC,mBAAO,CAAC,+CAAiB;AAC5D,gCAAgC,mBAAO,CAAC,qDAAoB;AAC5D,+BAA+B,mBAAO,CAAC,mDAAmB;AAC1D,iCAAiC,mBAAO,CAAC,uDAAqB;AAC9D,uCAAuC,mBAAO,CAAC,mEAA2B;AAC1E,qCAAqC,mBAAO,CAAC,+DAAyB;AACtE,kCAAkC,mBAAO,CAAC,yDAAsB;AAChE,kCAAkC,mBAAO,CAAC,yDAAsB;AAChE,iCAAiC,mBAAO,CAAC,uDAAqB;AAC9D,8CAA8C,mBAAO,CAAC,iFAAkC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrCa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D,+BAA+B,mBAAO,CAAC,kCAAQ;AAC/C,cAAc,mBAAO,CAAC,wCAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/Ba;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D,+BAA+B,mBAAO,CAAC,kCAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;ACtJa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D,+BAA+B,mBAAO,CAAC,kCAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5Ka;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D,8BAA8B,mBAAO,CAAC,wCAAc;AACpD,uCAAuC,mBAAO,CAAC,wDAAsB;AACrE,oCAAoC,mBAAO,CAAC,kDAAmB;AAC/D,mCAAmC,mBAAO,CAAC,gDAAkB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,eAAe,gBAAgB;AAC/B;AACA;AACA,yCAAyC,iBAAiB;AAC1D;AACA;AACA;AACA;AACA,uBAAuB;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA,oCAAoC,iBAAiB;AACrD;AACA;AACA,2EAA2E,gBAAgB;AAC3F;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA,wCAAwC,iBAAiB;AACzD;AACA;AACA,+EAA+E,iBAAiB;AAChG;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxPa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D,gCAAgC,mBAAO,CAAC,0CAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjDa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D,gCAAgC,mBAAO,CAAC,0CAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7Ba;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D,gCAAgC,mBAAO,CAAC,0CAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1Ca;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D,gCAAgC,mBAAO,CAAC,0CAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7Da;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D,gCAAgC,mBAAO,CAAC,0CAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvCa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D,gCAAgC,mBAAO,CAAC,0CAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3Ba;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D,gCAAgC,mBAAO,CAAC,0CAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7Da;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D,gCAAgC,mBAAO,CAAC,0CAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1Ba;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D,mCAAmC,mBAAO,CAAC,2CAAa;AACxD;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACda;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D,gCAAgC,mBAAO,CAAC,oCAAS;AACjD,gCAAgC,mBAAO,CAAC,8CAAiB;AACzD,gCAAgC,mBAAO,CAAC,4CAAgB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtJa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D,+BAA+B,mBAAO,CAAC,kCAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxBa;AACb;AACA,4CAA4C;AAC5C;AACA,8CAA8C,cAAc;AAC5D,gCAAgC,mBAAO,CAAC,0CAAe;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrFa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA,wCAAwC;AACxC,4BAA4B;AAC5B,4BAA4B;AAC5B;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,kCAAkC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uDAAuD;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3Qa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"miniProgramRC\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"miniProgramRC\"] = factory();\n\telse\n\t\troot[\"miniProgramRC\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst _type = Symbol('type');\nconst _bubbles = Symbol('bubbles');\nconst _originalEvent = Symbol('_originalEvent');\nclass Event {\n    constructor() {\n        this[_type] = '';\n        this[_originalEvent] = null;\n        this[_bubbles] = true;\n        this.cancelBubble = false;\n    }\n    stopPropagation() {\n        this.cancelBubble = true;\n    }\n    get type() {\n        return this[_type];\n    }\n    set type(value) {\n        this[_type] = value;\n    }\n    get originalEvent() {\n        return this[_originalEvent];\n    }\n    set originalEvent(value) {\n        this[_originalEvent] = value;\n    }\n    get bubbles() {\n        return this[_bubbles];\n    }\n    set bubbles(value) {\n        this[_bubbles] = value;\n    }\n}\nexports.default = Event;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst matrix2d_1 = __importDefault(require(\"./matrix2d\"));\nclass DisplayProps {\n    constructor(visible, alpha, shadow, compositeOperation, matrix) {\n        this.setValue(visible, alpha, shadow, compositeOperation, matrix);\n    }\n    setValue(visible, alpha, shadow, compositeOperation, matrix) {\n        this.visible = visible == null ? true : visible;\n        this.alpha = alpha == null ? 1 : alpha;\n        this.shadow = shadow || null;\n        this.compositeOperation = compositeOperation || null;\n        this.matrix = matrix || (this.matrix && this.matrix.identity()) || new matrix2d_1.default();\n        return this;\n    }\n    append(visible, alpha, shadow, compositeOperation, matrix) {\n        this.alpha *= alpha;\n        this.shadow = shadow || this.shadow;\n        this.compositeOperation = compositeOperation || this.compositeOperation;\n        this.visible = this.visible && visible;\n        matrix && this.matrix.appendMatrix(matrix);\n        return this;\n    }\n    prepend(visible, alpha, shadow, compositeOperation, matrix) {\n        this.alpha *= alpha;\n        this.shadow = this.shadow || shadow;\n        this.compositeOperation = this.compositeOperation || compositeOperation;\n        this.visible = this.visible && visible;\n        matrix && this.matrix.prependMatrix(matrix);\n        return this;\n    }\n    identity() {\n        this.visible = true;\n        this.alpha = 1;\n        this.shadow = this.compositeOperation = null;\n        this.matrix.identity();\n        return this;\n    }\n}\nexports.default = DisplayProps;\n","/*\n * Matrix2D\n * Visit http://createjs.com/ for documentation, updates and examples.\n *\n * Copyright (c) 2010 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n// constructor:\n/**\n * Represents an affine transformation matrix, and provides tools for constructing and concatenating matrices.\n *\n * This matrix can be visualized as:\n *\n * \t[ a  c  tx\n * \t  b  d  ty\n * \t  0  0  1  ]\n *\n * Note the locations of b and c.\n *\n * @class Matrix2D\n * @param {Number} [a=1] Specifies the a property for the new matrix.\n * @param {Number} [b=0] Specifies the b property for the new matrix.\n * @param {Number} [c=0] Specifies the c property for the new matrix.\n * @param {Number} [d=1] Specifies the d property for the new matrix.\n * @param {Number} [tx=0] Specifies the tx property for the new matrix.\n * @param {Number} [ty=0] Specifies the ty property for the new matrix.\n * @constructor\n **/\nfunction Matrix2D(a, b, c, d, tx, ty) {\n  this.setValues(a, b, c, d, tx, ty);\n\n  // public properties:\n  // assigned in the setValues method.\n  /**\n   * Position (0, 0) in a 3x3 affine transformation matrix.\n   * @property a\n   * @type Number\n   **/\n\n  /**\n   * Position (0, 1) in a 3x3 affine transformation matrix.\n   * @property b\n   * @type Number\n   **/\n\n  /**\n   * Position (1, 0) in a 3x3 affine transformation matrix.\n   * @property c\n   * @type Number\n   **/\n\n  /**\n   * Position (1, 1) in a 3x3 affine transformation matrix.\n   * @property d\n   * @type Number\n   **/\n\n  /**\n   * Position (2, 0) in a 3x3 affine transformation matrix.\n   * @property tx\n   * @type Number\n   **/\n\n  /**\n   * Position (2, 1) in a 3x3 affine transformation matrix.\n   * @property ty\n   * @type Number\n   **/\n}\nvar p = Matrix2D.prototype;\n\n// constants:\n/**\n * Multiplier for converting degrees to radians. Used internally by Matrix2D.\n * @property DEG_TO_RAD\n * @static\n * @final\n * @type Number\n * @readonly\n **/\nMatrix2D.DEG_TO_RAD = Math.PI / 180;\n\n// static public properties:\n/**\n * An identity matrix, representing a null transformation.\n * @property identity\n * @static\n * @type Matrix2D\n * @readonly\n **/\nMatrix2D.identity = null; // set at bottom of class definition.\n\n// public methods:\n/**\n * Sets the specified values on this instance.\n * @method setValues\n * @param {Number} [a=1] Specifies the a property for the new matrix.\n * @param {Number} [b=0] Specifies the b property for the new matrix.\n * @param {Number} [c=0] Specifies the c property for the new matrix.\n * @param {Number} [d=1] Specifies the d property for the new matrix.\n * @param {Number} [tx=0] Specifies the tx property for the new matrix.\n * @param {Number} [ty=0] Specifies the ty property for the new matrix.\n * @return {Matrix2D} This instance. Useful for chaining method calls.\n */\np.setValues = function (a, b, c, d, tx, ty) {\n  // don't forget to update docs in the constructor if these change:\n  this.a = a == null ? 1 : a;\n  this.b = b || 0;\n  this.c = c || 0;\n  this.d = d == null ? 1 : d;\n  this.tx = tx || 0;\n  this.ty = ty || 0;\n  return this;\n};\n\n/**\n * Appends the specified matrix properties to this matrix. All parameters are required.\n * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.\n * @method append\n * @param {Number} a\n * @param {Number} b\n * @param {Number} c\n * @param {Number} d\n * @param {Number} tx\n * @param {Number} ty\n * @return {Matrix2D} This matrix. Useful for chaining method calls.\n **/\np.append = function (a, b, c, d, tx, ty) {\n  var a1 = this.a;\n  var b1 = this.b;\n  var c1 = this.c;\n  var d1 = this.d;\n  if (a != 1 || b != 0 || c != 0 || d != 1) {\n    this.a = a1 * a + c1 * b;\n    this.b = b1 * a + d1 * b;\n    this.c = a1 * c + c1 * d;\n    this.d = b1 * c + d1 * d;\n  }\n  this.tx = a1 * tx + c1 * ty + this.tx;\n  this.ty = b1 * tx + d1 * ty + this.ty;\n  return this;\n};\n\n/**\n * Prepends the specified matrix properties to this matrix.\n * This is the equivalent of multiplying `(specified matrix) * (this matrix)`.\n * All parameters are required.\n * @method prepend\n * @param {Number} a\n * @param {Number} b\n * @param {Number} c\n * @param {Number} d\n * @param {Number} tx\n * @param {Number} ty\n * @return {Matrix2D} This matrix. Useful for chaining method calls.\n **/\np.prepend = function (a, b, c, d, tx, ty) {\n  var a1 = this.a;\n  var c1 = this.c;\n  var tx1 = this.tx;\n\n  this.a = a * a1 + c * this.b;\n  this.b = b * a1 + d * this.b;\n  this.c = a * c1 + c * this.d;\n  this.d = b * c1 + d * this.d;\n  this.tx = a * tx1 + c * this.ty + tx;\n  this.ty = b * tx1 + d * this.ty + ty;\n  return this;\n};\n\n/**\n * Appends the specified matrix to this matrix.\n * This is the equivalent of multiplying `(this matrix) * (specified matrix)`.\n * @method appendMatrix\n * @param {Matrix2D} matrix\n * @return {Matrix2D} This matrix. Useful for chaining method calls.\n **/\np.appendMatrix = function (matrix) {\n  return this.append(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);\n};\n\n/**\n * Prepends the specified matrix to this matrix.\n * This is the equivalent of multiplying `(specified matrix) * (this matrix)`.\n * For example, you could calculate the combined transformation for a child object using:\n *\n * \tvar o = myDisplayObject;\n * \tvar mtx = o.getMatrix();\n * \twhile (o = o.parent) {\n * \t\t// prepend each parent's transformation in turn:\n * \t\to.prependMatrix(o.getMatrix());\n * \t}\n * @method prependMatrix\n * @param {Matrix2D} matrix\n * @return {Matrix2D} This matrix. Useful for chaining method calls.\n **/\np.prependMatrix = function (matrix) {\n  return this.prepend(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);\n};\n\n/**\n * Generates matrix properties from the specified display object transform properties, and appends them to this matrix.\n * For example, you can use this to generate a matrix representing the transformations of a display object:\n *\n * \tvar mtx = new createjs.Matrix2D();\n * \tmtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation);\n * @method appendTransform\n * @param {Number} x\n * @param {Number} y\n * @param {Number} scaleX\n * @param {Number} scaleY\n * @param {Number} rotation\n * @param {Number} skewX\n * @param {Number} skewY\n * @param {Number} regX Optional.\n * @param {Number} regY Optional.\n * @return {Matrix2D} This matrix. Useful for chaining method calls.\n **/\np.appendTransform = function (x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {\n  if (rotation % 360) {\n    var r = rotation * Matrix2D.DEG_TO_RAD;\n    var cos = Math.cos(r);\n    var sin = Math.sin(r);\n  } else {\n    cos = 1;\n    sin = 0;\n  }\n\n  if (skewX || skewY) {\n    // TODO: can this be combined into a single append operation?\n    skewX *= Matrix2D.DEG_TO_RAD;\n    skewY *= Matrix2D.DEG_TO_RAD;\n    this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);\n    this.append(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, 0, 0);\n  } else {\n    this.append(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, x, y);\n  }\n\n  if (regX || regY) {\n    // append the registration offset:\n    this.tx -= regX * this.a + regY * this.c;\n    this.ty -= regX * this.b + regY * this.d;\n  }\n  return this;\n};\n\n/**\n * Generates matrix properties from the specified display object transform properties, and prepends them to this matrix.\n * For example, you could calculate the combined transformation for a child object using:\n *\n * \tvar o = myDisplayObject;\n * \tvar mtx = new createjs.Matrix2D();\n * \tdo  {\n * \t\t// prepend each parent's transformation in turn:\n * \t\tmtx.prependTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.regX, o.regY);\n * \t} while (o = o.parent);\n *\n * \tNote that the above example would not account for {{#crossLink \"DisplayObject/transformMatrix:property\"}}{{/crossLink}}\n * \tvalues. See {{#crossLink \"Matrix2D/prependMatrix\"}}{{/crossLink}} for an example that does.\n * @method prependTransform\n * @param {Number} x\n * @param {Number} y\n * @param {Number} scaleX\n * @param {Number} scaleY\n * @param {Number} rotation\n * @param {Number} skewX\n * @param {Number} skewY\n * @param {Number} regX Optional.\n * @param {Number} regY Optional.\n * @return {Matrix2D} This matrix. Useful for chaining method calls.\n **/\np.prependTransform = function (x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {\n  if (rotation % 360) {\n    var r = rotation * Matrix2D.DEG_TO_RAD;\n    var cos = Math.cos(r);\n    var sin = Math.sin(r);\n  } else {\n    cos = 1;\n    sin = 0;\n  }\n\n  if (regX || regY) {\n    // prepend the registration offset:\n    this.tx -= regX;\n    this.ty -= regY;\n  }\n  if (skewX || skewY) {\n    // TODO: can this be combined into a single prepend operation?\n    skewX *= Matrix2D.DEG_TO_RAD;\n    skewY *= Matrix2D.DEG_TO_RAD;\n    this.prepend(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, 0, 0);\n    this.prepend(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);\n  } else {\n    this.prepend(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, x, y);\n  }\n  return this;\n};\n\n/**\n * Applies a clockwise rotation transformation to the matrix.\n * @method rotate\n * @param {Number} angle The angle to rotate by, in degrees. To use a value in radians, multiply it by `Math.PI/180`.\n * @return {Matrix2D} This matrix. Useful for chaining method calls.\n **/\np.rotate = function (angle) {\n  angle = angle * Matrix2D.DEG_TO_RAD;\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n\n  var a1 = this.a;\n  var b1 = this.b;\n\n  this.a = a1 * cos + this.c * sin;\n  this.b = b1 * cos + this.d * sin;\n  this.c = -a1 * sin + this.c * cos;\n  this.d = -b1 * sin + this.d * cos;\n  return this;\n};\n\n/**\n * Applies a skew transformation to the matrix.\n * @method skew\n * @param {Number} skewX The amount to skew horizontally in degrees. To use a value in radians, multiply it by `Math.PI/180`.\n * @param {Number} skewY The amount to skew vertically in degrees.\n * @return {Matrix2D} This matrix. Useful for chaining method calls.\n */\np.skew = function (skewX, skewY) {\n  skewX = skewX * Matrix2D.DEG_TO_RAD;\n  skewY = skewY * Matrix2D.DEG_TO_RAD;\n  this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), 0, 0);\n  return this;\n};\n\n/**\n * Applies a scale transformation to the matrix.\n * @method scale\n * @param {Number} x The amount to scale horizontally. E.G. a value of 2 will double the size in the X direction, and 0.5 will halve it.\n * @param {Number} y The amount to scale vertically.\n * @return {Matrix2D} This matrix. Useful for chaining method calls.\n **/\np.scale = function (x, y) {\n  this.a *= x;\n  this.b *= x;\n  this.c *= y;\n  this.d *= y;\n  //this.tx *= x;\n  //this.ty *= y;\n  return this;\n};\n\n/**\n * Translates the matrix on the x and y axes.\n * @method translate\n * @param {Number} x\n * @param {Number} y\n * @return {Matrix2D} This matrix. Useful for chaining method calls.\n **/\np.translate = function (x, y) {\n  this.tx += this.a * x + this.c * y;\n  this.ty += this.b * x + this.d * y;\n  return this;\n};\n\n/**\n * Sets the properties of the matrix to those of an identity matrix (one that applies a null transformation).\n * @method identity\n * @return {Matrix2D} This matrix. Useful for chaining method calls.\n **/\np.identity = function () {\n  this.a = this.d = 1;\n  this.b = this.c = this.tx = this.ty = 0;\n  return this;\n};\n\n/**\n * Inverts the matrix, causing it to perform the opposite transformation.\n * @method invert\n * @return {Matrix2D} This matrix. Useful for chaining method calls.\n **/\np.invert = function () {\n  var a1 = this.a;\n  var b1 = this.b;\n  var c1 = this.c;\n  var d1 = this.d;\n  var tx1 = this.tx;\n  var n = a1 * d1 - b1 * c1;\n\n  this.a = d1 / n;\n  this.b = -b1 / n;\n  this.c = -c1 / n;\n  this.d = a1 / n;\n  this.tx = (c1 * this.ty - d1 * tx1) / n;\n  this.ty = -(a1 * this.ty - b1 * tx1) / n;\n  return this;\n};\n\n/**\n * Returns true if the matrix is an identity matrix.\n * @method isIdentity\n * @return {Boolean}\n **/\np.isIdentity = function () {\n  return (\n    this.tx === 0 && this.ty === 0 && this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1\n  );\n};\n\n/**\n * Returns true if this matrix is equal to the specified matrix (all property values are equal).\n * @method equals\n * @param {Matrix2D} matrix The matrix to compare.\n * @return {Boolean}\n **/\np.equals = function (matrix) {\n  return (\n    this.tx === matrix.tx &&\n    this.ty === matrix.ty &&\n    this.a === matrix.a &&\n    this.b === matrix.b &&\n    this.c === matrix.c &&\n    this.d === matrix.d\n  );\n};\n\n/**\n * Transforms a point according to this matrix.\n * @method transformPoint\n * @param {Number} x The x component of the point to transform.\n * @param {Number} y The y component of the point to transform.\n * @param {Point | Object} [pt] An object to copy the result into. If omitted a generic object with x/y properties will be returned.\n * @return {Point} This matrix. Useful for chaining method calls.\n **/\np.transformPoint = function (x, y, pt) {\n  pt = pt || {};\n  pt.x = x * this.a + y * this.c + this.tx;\n  pt.y = x * this.b + y * this.d + this.ty;\n  return pt;\n};\n\n/**\n * Decomposes the matrix into transform properties (x, y, scaleX, scaleY, and rotation). Note that these values\n * may not match the transform properties you used to generate the matrix, though they will produce the same visual\n * results.\n * @method decompose\n * @param {Object} target The object to apply the transform properties to. If null, then a new object will be returned.\n * @return {Object} The target, or a new generic object with the transform properties applied.\n */\np.decompose = function (target) {\n  // TODO: it would be nice to be able to solve for whether the matrix can be decomposed into only scale/rotation even when scale is negative\n  if (target == null) {\n    target = {};\n  }\n  target.x = this.tx;\n  target.y = this.ty;\n  target.scaleX = Math.sqrt(this.a * this.a + this.b * this.b);\n  target.scaleY = Math.sqrt(this.c * this.c + this.d * this.d);\n\n  var skewX = Math.atan2(-this.c, this.d);\n  var skewY = Math.atan2(this.b, this.a);\n\n  var delta = Math.abs(1 - skewX / skewY);\n  if (delta < 0.00001) {\n    // effectively identical, can use rotation:\n    target.rotation = skewY / Matrix2D.DEG_TO_RAD;\n    if (this.a < 0 && this.d >= 0) {\n      target.rotation += target.rotation <= 0 ? 180 : -180;\n    }\n    target.skewX = target.skewY = 0;\n  } else {\n    target.skewX = skewX / Matrix2D.DEG_TO_RAD;\n    target.skewY = skewY / Matrix2D.DEG_TO_RAD;\n  }\n  return target;\n};\n\n/**\n * Copies all properties from the specified matrix to this matrix.\n * @method copy\n * @param {Matrix2D} matrix The matrix to copy properties from.\n * @return {Matrix2D} This matrix. Useful for chaining method calls.\n */\np.copy = function (matrix) {\n  return this.setValues(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);\n};\n\n/**\n * Returns a clone of the Matrix2D instance.\n * @method clone\n * @return {Matrix2D} a clone of the Matrix2D instance.\n **/\np.clone = function () {\n  return new Matrix2D(this.a, this.b, this.c, this.d, this.tx, this.ty);\n};\n\n/**\n * Returns a string representation of this object.\n * @method toString\n * @return {String} a string representation of the instance.\n **/\np.toString = function () {\n  return (\n    '[Matrix2D (a=' +\n    this.a +\n    ' b=' +\n    this.b +\n    ' c=' +\n    this.c +\n    ' d=' +\n    this.d +\n    ' tx=' +\n    this.tx +\n    ' ty=' +\n    this.ty +\n    ')]'\n  );\n};\n\n// this has to be populated after the class is defined:\nMatrix2D.identity = new Matrix2D();\n\nexport default Matrix2D;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Rectangle {\n    constructor(x, y, width, height) {\n        this.setValues(x, y, width, height);\n    }\n    setValues(x, y, width, height) {\n        this.x = x || 0;\n        this.y = y || 0;\n        this.width = width || 0;\n        this.height = height || 0;\n        return this;\n    }\n    extend(x, y, width, height) {\n        width = width || 0;\n        height = height || 0;\n        if (x + width > this.x + this.width) {\n            this.width = x + width - this.x;\n        }\n        if (y + height > this.y + this.height) {\n            this.height = y + height - this.y;\n        }\n        if (x < this.x) {\n            this.width += this.x - x;\n            this.x = x;\n        }\n        if (y < this.y) {\n            this.height += this.y - y;\n            this.y = y;\n        }\n        return this;\n    }\n    copy(rectangle) {\n        return this.setValues(rectangle.x, rectangle.y, rectangle.width, rectangle.height);\n    }\n    contains(x, y, width, height) {\n        width = width || 0;\n        height = height || 0;\n        return (x >= this.x &&\n            x + width <= this.x + this.width &&\n            y >= this.y &&\n            y + height <= this.y + this.height);\n    }\n    isEmpty() {\n        return this.width <= 0 || this.height <= 0;\n    }\n    clone() {\n        return new Rectangle(this.x, this.y, this.width, this.height);\n    }\n}\nexports.default = Rectangle;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst index_1 = __importDefault(require(\"./render/index\"));\nconst stage_1 = __importDefault(require(\"./node/stage\"));\nconst group_1 = __importDefault(require(\"./node/group\"));\nconst bitmap_1 = __importDefault(require(\"./node/bitmap\"));\nconst text_1 = __importDefault(require(\"./node/text\"));\nconst graphics_1 = __importDefault(require(\"./node/graphics\"));\nconst shape_1 = __importDefault(require(\"./node/shape/shape\"));\nconst rect_1 = __importDefault(require(\"./node/shape/rect\"));\nconst circle_1 = __importDefault(require(\"./node/shape/circle\"));\nconst rounded_rect_1 = __importDefault(require(\"./node/shape/rounded-rect\"));\nconst arrow_path_1 = __importDefault(require(\"./node/shape/arrow-path\"));\nconst ellipse_1 = __importDefault(require(\"./node/shape/ellipse\"));\nconst polygon_1 = __importDefault(require(\"./node/shape/polygon\"));\nconst sector_1 = __importDefault(require(\"./node/shape/sector\"));\nconst equilateral_polygon_1 = __importDefault(require(\"./node/shape/equilateral-polygon\"));\nconst cax = {\n    Render: index_1.default,\n    Stage: stage_1.default,\n    Group: group_1.default,\n    Bitmap: bitmap_1.default,\n    Text: text_1.default,\n    Graphics: graphics_1.default,\n    Shape: shape_1.default,\n    Rect: rect_1.default,\n    Circle: circle_1.default,\n    RoundedRect: rounded_rect_1.default,\n    ArrowPath: arrow_path_1.default,\n    Ellipse: ellipse_1.default,\n    Polygon: polygon_1.default,\n    Sector: sector_1.default,\n    EquilateralPolygon: equilateral_polygon_1.default,\n};\nexports.default = cax;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst node_1 = __importDefault(require(\"./node\"));\nconst lru_1 = require(\"../utils/lru\");\nclass Bitmap extends node_1.default {\n    constructor(img) {\n        super();\n        let image = Bitmap.cache.get(img.src, false);\n        if (image) {\n            this.img = image;\n            this.rect = [0, 0, this.img.width, this.img.height];\n            this.width = this.img.width;\n            this.height = this.img.height;\n        }\n        else {\n            this.img = img;\n            this.rect = [0, 0, img.width, img.height];\n            this.width = img.width;\n            this.height = img.height;\n            Bitmap.cache.put(img.src, image);\n        }\n    }\n    render(ctx) {\n        let rect = this.rect;\n        ctx.drawImage(this.img, rect[0], rect[1], rect[2], rect[3], 0, 0, rect[2], rect[3]);\n    }\n}\nBitmap.cache = lru_1.MakeLRUCache(50);\nexports.default = Bitmap;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst node_1 = __importDefault(require(\"./node\"));\nconst assMap = {\n    fillStyle: true,\n    strokeStyle: true,\n    lineWidth: true,\n    lineCap: true,\n    lineDashOffset: true,\n    lineJoin: true,\n    miterLimit: true\n};\nclass Graphics extends node_1.default {\n    constructor() {\n        super();\n        this.cmds = [];\n        this.currentGradient = null;\n    }\n    clearRect(...params) {\n        this.cmds.push(['clearRect', arguments]);\n        return this;\n    }\n    rect(...params) {\n        this.cmds.push(['rect', arguments]);\n        return this;\n    }\n    clear(...params) {\n        this.cmds.length = 0;\n        return this;\n    }\n    setLineDash(...params) {\n        this.cmds.push(['setLineDash', arguments]);\n        return this;\n    }\n    strokeRect(...params) {\n        this.cmds.push(['strokeRect', arguments]);\n        return this;\n    }\n    fillRect(...params) {\n        this.cmds.push(['fillRect', arguments]);\n        return this;\n    }\n    beginPath(...params) {\n        this.cmds.push(['beginPath', arguments]);\n        return this;\n    }\n    arc(...params) {\n        this.cmds.push(['arc', arguments]);\n        return this;\n    }\n    closePath(...params) {\n        this.cmds.push(['closePath', arguments]);\n        return this;\n    }\n    fillStyle(...params) {\n        this.cmds.push(['fillStyle', arguments]);\n        return this;\n    }\n    fill(...params) {\n        this.cmds.push(['fill', arguments]);\n        return this;\n    }\n    strokeStyle(...params) {\n        this.cmds.push(['strokeStyle', arguments]);\n        return this;\n    }\n    lineWidth(...params) {\n        this.cmds.push(['lineWidth', arguments]);\n        return this;\n    }\n    lineCap(...params) {\n        this.cmds.push(['lineCap', arguments]);\n        return this;\n    }\n    lineDashOffset(...params) {\n        this.cmds.push(['lineDashOffset', arguments]);\n        return this;\n    }\n    lineJoin(...params) {\n        this.cmds.push(['lineJoin', arguments]);\n        return this;\n    }\n    miterLimit(...params) {\n        this.cmds.push(['miterLimit', arguments]);\n        return this;\n    }\n    stroke(...params) {\n        this.cmds.push(['stroke', arguments]);\n        return this;\n    }\n    moveTo(...params) {\n        this.cmds.push(['moveTo', arguments]);\n        return this;\n    }\n    lineTo(...params) {\n        this.cmds.push(['lineTo', arguments]);\n        return this;\n    }\n    bezierCurveTo(...params) {\n        this.cmds.push(['bezierCurveTo', arguments]);\n        return this;\n    }\n    quadraticCurveTo(...params) {\n        this.cmds.push(['quadraticCurveTo', arguments]);\n        return this;\n    }\n    createRadialGradient(...params) {\n        this.cmds.push(['createRadialGradient', arguments]);\n        return this;\n    }\n    createLinearGradient(...params) {\n        this.cmds.push(['createLinearGradient', arguments]);\n        return this;\n    }\n    addColorStop(...params) {\n        this.cmds.push(['addColorStop', arguments]);\n        return this;\n    }\n    fillGradient(...params) {\n        this.cmds.push(['fillGradient']);\n        return this;\n    }\n    arcTo(...params) {\n        this.cmds.push(['arcTo', arguments]);\n        return this;\n    }\n    render(ctx) {\n        this.cmds.forEach(cmd => {\n            const methodName = cmd[0];\n            if (assMap[methodName]) {\n                ctx[methodName] = cmd[1][0];\n            }\n            else if (methodName === 'addColorStop') {\n                this.currentGradient && this.currentGradient.addColorStop(cmd[1][0], cmd[1][1]);\n            }\n            else if (methodName === 'fillGradient') {\n                ctx.fillStyle = this.currentGradient;\n            }\n            else {\n                let result = ctx[methodName].apply(ctx, Array.prototype.slice.call(cmd[1]));\n                if (methodName === 'createRadialGradient' || methodName === 'createLinearGradient') {\n                    this.currentGradient = result;\n                }\n            }\n        });\n    }\n}\nexports.default = Graphics;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst node_1 = __importDefault(require(\"./node\"));\nclass Group extends node_1.default {\n    constructor() {\n        super();\n        this.children = [];\n        this.mouseChildren = true;\n    }\n    add(child) {\n        const len = arguments.length;\n        for (let i = 0; i < len; i++) {\n            const c = arguments[i];\n            const parent = c.parent;\n            if (parent) {\n                parent.removeChildAt(parent.children.indexOf(c));\n            }\n            this.children.push(c);\n            c.parent = this;\n        }\n    }\n    addChildAt(child, index) {\n        let par = child.parent;\n        par && par.removeChildAt(par.children.indexOf(child));\n        child.parent = this;\n        this.children.splice(index, 0, child);\n    }\n    removeChildAt(index) {\n        let child = this.children[index];\n        if (child) {\n            child.parent = null;\n        }\n        this.children.splice(index, 1);\n    }\n    removeLastChild() {\n        let len = this.children.length || 0;\n        if (len > 0) {\n            let child = this.children[len - 1];\n            if (child) {\n                child.parent = null;\n            }\n            this.children.pop();\n        }\n    }\n    replace(current, pre) {\n        const index = pre.parent.children.indexOf(pre);\n        this.removeChildAt(index);\n        this.addChildAt(current, index);\n    }\n    remove(child) {\n        if (!child)\n            return;\n        const len = arguments.length;\n        let cLen = this.children.length;\n        for (let i = 0; i < len; i++) {\n            for (let j = 0; j < cLen; j++) {\n                if (child.id === this.children[j].id) {\n                    child.parent = null;\n                    this.children.splice(j, 1);\n                    j--;\n                    cLen--;\n                }\n            }\n        }\n    }\n    empty() {\n        this.children.forEach(child => {\n            child.parent = null;\n        });\n        this.children.length = 0;\n    }\n    destroy() {\n        this.empty();\n        this.parent && this.parent.destroy();\n    }\n    _getObjectsUnderPoint(x, y, hitCtx) {\n        const ctx = hitCtx;\n        if (!this._testMask(this, x, y, ctx)) {\n            return null;\n        }\n        let children = this.children;\n        let l = children.length;\n        for (let i = l - 1; i >= 0; i--) {\n            let child = children[i];\n            let hitBox = child.hitBox;\n            if (!child.isVisible() || child.ignoreHit) {\n                continue;\n            }\n            if (!this._testMask(child, x, y, ctx)) {\n                continue;\n            }\n            if (!hitBox && child instanceof Group) {\n                let result = child._getObjectsUnderPoint(x, y, ctx);\n                if (result)\n                    return !this.mouseChildren ? this : result;\n            }\n            else {\n                let props = child.getConcatenatedDisplayProps(child._props);\n                let mtx = props.matrix;\n                if (hitBox) {\n                    let mtxClone = mtx.clone();\n                    child.setBounds(hitBox[0], hitBox[1], hitBox[2], hitBox[3]);\n                    let bounds = child._getBounds(mtxClone, true);\n                    let AABB = [bounds.x, bounds.y, bounds.width, bounds.height];\n                    if (!this.checkPointInAABB(x, y, AABB)) {\n                        continue;\n                    }\n                    if (child instanceof Group) {\n                        let result = child._getObjectsUnderPoint(x, y, ctx);\n                        if (result) {\n                            return !this.mouseChildren ? this : result;\n                        }\n                        else {\n                            return child;\n                        }\n                    }\n                }\n                ctx.globalAlpha = props.alpha;\n                ctx.setTransform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx - x, mtx.ty - y);\n                child.render(ctx);\n                if (!this._testHit(ctx)) {\n                    continue;\n                }\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.clearRect(0, 0, 2, 2);\n                return !this.mouseChildren ? this : child;\n            }\n        }\n        return null;\n    }\n    _testMask(target, x, y, hitCtx) {\n        const ctx = hitCtx;\n        const mask = target.mask;\n        if (!mask) {\n            return true;\n        }\n        let mtx = this._props.matrix;\n        let parent = target.parent;\n        mtx = parent ? parent.getConcatenatedMatrix(mtx) : mtx.identity();\n        mtx = mask.getMatrix(mask._props.matrix).prependMatrix(mtx);\n        ctx.beginPath();\n        ctx.setTransform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx - x, mtx.ty - y);\n        mask.render(ctx);\n        ctx.fillStyle = '#000';\n        ctx.fill();\n        if (!this._testHit(ctx)) {\n            return false;\n        }\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.clearRect(0, 0, 2, 2);\n        return true;\n    }\n    _testHit(ctx) {\n        return ctx.getImageData(0, 0, 1, 1).data[3] > 1;\n    }\n    checkPointInAABB(x, y, AABB) {\n        let minX = AABB[0];\n        if (x < minX)\n            return false;\n        let minY = AABB[1];\n        if (y < minY)\n            return false;\n        let maxX = minX + AABB[2];\n        if (x > maxX)\n            return false;\n        let maxY = minY + AABB[3];\n        return y <= maxY;\n    }\n}\nexports.default = Group;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst uid_1 = __importDefault(require(\"../utils/uid\"));\nconst displayProps_1 = __importDefault(require(\"../geom/displayProps\"));\nconst rectangle_1 = __importDefault(require(\"../geom/rectangle\"));\nconst matrix2d_1 = __importDefault(require(\"../geom/matrix2d\"));\nconst _eventListeners = Symbol('eventListeners');\nconst _captureEventListeners = Symbol('captureEventListeners');\nclass Node {\n    constructor() {\n        this[_eventListeners] = {};\n        this[_captureEventListeners] = {};\n        this.parent = null;\n        this.id = uid_1.default.get();\n        this.x = 0;\n        this.y = 0;\n        this.scale = 1;\n        this.scaleX = 1;\n        this.scaleY = 1;\n        this.rotation = 0;\n        this.skewX = 0;\n        this.skewY = 0;\n        this.regX = 0;\n        this.regY = 0;\n        this.alpha = 1;\n        this.visible = true;\n        this.shadow = null;\n        this.mask = null;\n        this._props = new displayProps_1.default();\n        this._rectangle = new rectangle_1.default();\n        this._bounds = null;\n        this.compositeOperation = null;\n        this.hitBox = null;\n        this.ignoreHit = false;\n    }\n    get stage() {\n        let o = this;\n        while (o.parent) {\n            o = o.parent;\n        }\n        if (o.___instanceof === 'Stage') {\n            return o;\n        }\n    }\n    get scale() {\n        return this.scaleX;\n    }\n    set scale(scale) {\n        this.scaleX = this.scaleY = scale;\n    }\n    isVisible() {\n        return this.visible && this.alpha > 0 && this.scaleX !== 0 && this.scaleY !== 0;\n    }\n    clip(graphics) {\n        this.mask = graphics;\n    }\n    unclip() {\n        this.mask = null;\n    }\n    setTransform(x, y, scaleX, scaleY, rotation, skewX, skewY, regX, regY) {\n        this.x = x || 0;\n        this.y = y || 0;\n        this.scaleX = scaleX == null ? 1 : scaleX;\n        this.scaleY = scaleY == null ? 1 : scaleY;\n        this.rotation = rotation || 0;\n        this.skewX = skewX || 0;\n        this.skewY = skewY || 0;\n        this.regX = regX || 0;\n        this.regY = regY || 0;\n        return this;\n    }\n    getMatrix(matrix) {\n        let o = this;\n        let mtx = matrix || new matrix2d_1.default();\n        return (mtx.identity() &&\n            mtx.appendTransform(o.x, o.y, o.scaleX, o.scaleY, o.rotation, o.skewX, o.skewY, o.regX, o.regY));\n    }\n    getConcatenatedMatrix(matrix) {\n        let o = this;\n        let mtx = this.getMatrix(matrix);\n        while ((o = o.parent)) {\n            mtx.prependMatrix(o.getMatrix(o._props.matrix));\n        }\n        return mtx;\n    }\n    getConcatenatedDisplayProps(props) {\n        props = props ? props.identity() : new displayProps_1.default();\n        let o = this;\n        let mtx = o.getMatrix(props.matrix);\n        do {\n            props.prepend(o.visible, o.alpha, o.shadow, o.compositeOperation);\n            if (o != this) {\n                mtx.prependMatrix(o.getMatrix(o._props.matrix));\n            }\n        } while ((o = o.parent));\n        return props;\n    }\n    getBounds() {\n        if (this._bounds) {\n            return this._rectangle.copy(this._bounds);\n        }\n        return null;\n    }\n    setBounds(x, y, width, height) {\n        if (x === null) {\n            this._bounds = null;\n            return;\n        }\n        this._bounds = (this._bounds || new rectangle_1.default()).setValues(x, y, width, height);\n    }\n    getTransformedBounds() {\n        return this._getBounds();\n    }\n    _getBounds(matrix, ignoreTransform) {\n        return this._transformBounds(this.getBounds(), matrix, ignoreTransform);\n    }\n    _transformBounds(bounds, matrix, ignoreTransform) {\n        if (!bounds) {\n            return bounds;\n        }\n        let x = bounds.x, y = bounds.y, width = bounds.width, height = bounds.height, mtx = this._props.matrix;\n        mtx = ignoreTransform ? mtx.identity() : this.getMatrix(mtx);\n        if (x || y) {\n            mtx.appendTransform(0, 0, 1, 1, 0, 0, 0, -x, -y);\n        }\n        if (matrix) {\n            mtx.prependMatrix(matrix);\n        }\n        let x_a = width * mtx.a, x_b = width * mtx.b;\n        let y_c = height * mtx.c, y_d = height * mtx.d;\n        let tx = mtx.tx, ty = mtx.ty;\n        let minX = tx, maxX = tx, minY = ty, maxY = ty;\n        if ((x = x_a + tx) < minX) {\n            minX = x;\n        }\n        else if (x > maxX) {\n            maxX = x;\n        }\n        if ((x = x_a + y_c + tx) < minX) {\n            minX = x;\n        }\n        else if (x > maxX) {\n            maxX = x;\n        }\n        if ((x = y_c + tx) < minX) {\n            minX = x;\n        }\n        else if (x > maxX) {\n            maxX = x;\n        }\n        if ((y = x_b + ty) < minY) {\n            minY = y;\n        }\n        else if (y > maxY) {\n            maxY = y;\n        }\n        if ((y = x_b + y_d + ty) < minY) {\n            minY = y;\n        }\n        else if (y > maxY) {\n            maxY = y;\n        }\n        if ((y = y_d + ty) < minY) {\n            minY = y;\n        }\n        else if (y > maxY) {\n            maxY = y;\n        }\n        return bounds.setValues(minX, minY, maxX - minX, maxY - minY);\n    }\n    on(type, listener, options) {\n        this.addEventListener(type, listener, options);\n    }\n    off(type, listener, options) {\n        this.removeEventListener(type, listener, options);\n    }\n    addEventListener(type, listener, options) {\n        if (typeof options === 'boolean')\n            options = { capture: options };\n        const { capture, once } = options || {};\n        const eventListeners = capture ? _captureEventListeners : _eventListeners;\n        this[eventListeners][type] = this[eventListeners][type] || [];\n        this[eventListeners][type].push({ listener, once });\n        return this;\n    }\n    removeEventListener(type, listener, options) {\n        if (typeof options === 'boolean')\n            options = { capture: options };\n        const { capture } = options || {};\n        const eventListeners = capture ? _captureEventListeners : _eventListeners;\n        if (this[eventListeners][type]) {\n            const listeners = this[eventListeners][type];\n            for (let i = 0; i < listeners.length; i++) {\n                const { listener: _listener } = listeners[i];\n                if (listener === _listener) {\n                    this[eventListeners][type].splice(i, 1);\n                    break;\n                }\n            }\n        }\n        return this;\n    }\n    dispatchEvent(event) {\n        event.target = this;\n        const type = event.type;\n        const elements = [this];\n        let parent = this.parent;\n        while (event.bubbles && parent) {\n            elements.push(parent);\n            parent = parent.parent;\n        }\n        // capture phase\n        for (let i = elements.length - 1; i >= 0; i--) {\n            const element = elements[i];\n            const listeners = element[_captureEventListeners] && element[_captureEventListeners][type];\n            if (listeners && listeners.length) {\n                listeners.forEach(({ listener, once }) => {\n                    listener.call(this, event);\n                    if (once) {\n                        element.removeEventListener(event.type, listener, { capture: true });\n                    }\n                });\n            }\n            if (!event.bubbles && event.cancelBubble)\n                break;\n        }\n        // bubbling\n        if (!event.cancelBubble) {\n            for (let i = 0; i < elements.length; i++) {\n                const element = elements[i];\n                const listeners = element[_eventListeners] && element[_eventListeners][type];\n                if (listeners && listeners.length) {\n                    listeners.forEach(({ listener, once }) => {\n                        listener.call(this, event);\n                        if (once) {\n                            element.removeEventListener(event.type, listener, { capture: false });\n                        }\n                    });\n                }\n                if (!event.bubbles || event.cancelBubble)\n                    break;\n            }\n        }\n    }\n}\nexports.default = Node;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst shape_1 = __importDefault(require(\"./shape\"));\nclass ArrowPath extends shape_1.default {\n    constructor(path, option) {\n        super();\n        this.path = path;\n        this.option = Object.assign({\n            strokeStyle: 'black',\n            lineWidth: 1,\n            headSize: 10\n        }, option);\n    }\n    draw() {\n        const path = this.path;\n        this.beginPath();\n        const len = path.length;\n        if (len === 2) {\n            this.drawArrow(path[0].x, path[0].y, path[1].x, path[1].y, 30);\n        }\n        else {\n            this.moveTo(path[0].x, path[0].y);\n            for (let i = 1; i < len - 1; i++) {\n                this.lineTo(path[i].x, path[i].y);\n            }\n            this.drawArrow(path[len - 2].x, path[len - 2].y, path[len - 1].x, path[len - 1].y, 30);\n        }\n        this.stroke();\n    }\n    drawArrow(fromX, fromY, toX, toY, theta) {\n        let angle = (Math.atan2(fromY - toY, fromX - toX) * 180) / Math.PI, angle1 = ((angle + theta) * Math.PI) / 180, angle2 = ((angle - theta) * Math.PI) / 180, hs = this.option.headSize, topX = hs * Math.cos(angle1), topY = hs * Math.sin(angle1), botX = hs * Math.cos(angle2), botY = hs * Math.sin(angle2);\n        let arrowX = fromX - topX, arrowY = fromY - topY;\n        this.moveTo(arrowX, arrowY);\n        this.moveTo(fromX, fromY);\n        this.lineTo(toX, toY);\n        arrowX = toX + topX;\n        arrowY = toY + topY;\n        this.moveTo(arrowX, arrowY);\n        this.lineTo(toX, toY);\n        arrowX = toX + botX;\n        arrowY = toY + botY;\n        this.lineTo(arrowX, arrowY);\n        this.strokeStyle(this.option.strokeStyle);\n        this.lineWidth(this.option.lineWidth);\n    }\n}\nexports.default = ArrowPath;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst shape_1 = __importDefault(require(\"./shape\"));\nclass Circle extends shape_1.default {\n    constructor(r, option) {\n        super();\n        this.option = option || {};\n        this.r = r;\n        this._dp = Math.PI * 2;\n    }\n    draw() {\n        this.beginPath();\n        this.arc(0, 0, this.r, 0, this._dp, false);\n        if (this.option.strokeStyle) {\n            if (this.option.lineWidth !== undefined) {\n                this.lineWidth(this.option.lineWidth);\n            }\n            this.strokeStyle(this.option.strokeStyle);\n            this.stroke();\n        }\n        if (this.option.fillStyle) {\n            this.fillStyle(this.option.fillStyle);\n            this.fill();\n        }\n    }\n}\nexports.default = Circle;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst shape_1 = __importDefault(require(\"./shape\"));\nclass Ellipse extends shape_1.default {\n    constructor(width, height, option) {\n        super();\n        this.option = option || {};\n        this.width = width;\n        this.height = height;\n    }\n    draw() {\n        const w = this.width;\n        const h = this.height;\n        const k = 0.5522848;\n        const ox = (w / 2) * k;\n        const oy = (h / 2) * k;\n        const xe = w;\n        const ye = h;\n        const xm = w / 2;\n        const ym = h / 2;\n        this.beginPath();\n        this.moveTo(0, ym);\n        this.bezierCurveTo(0, ym - oy, xm - ox, 0, xm, 0);\n        this.bezierCurveTo(xm + ox, 0, xe, ym - oy, xe, ym);\n        this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n        this.bezierCurveTo(xm - ox, ye, 0, ym + oy, 0, ym);\n        if (this.option.strokeStyle) {\n            if (this.option.lineWidth !== undefined) {\n                this.lineWidth(this.option.lineWidth);\n            }\n            this.strokeStyle(this.option.strokeStyle);\n            this.stroke();\n        }\n        if (this.option.fillStyle) {\n            this.fillStyle(this.option.fillStyle);\n            this.fill();\n        }\n    }\n}\nexports.default = Ellipse;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst shape_1 = __importDefault(require(\"./shape\"));\nclass EquilateralPolygon extends shape_1.default {\n    constructor(num, r, options) {\n        super();\n        this.num = num;\n        this.r = r;\n        this.options = options || {};\n        this.vertex = [];\n        this.initVertex();\n    }\n    initVertex() {\n        this.vertex.length = [];\n        const num = this.num;\n        const r = this.r;\n        let i, startX, startY, newX, newY;\n        if (num % 2 === 0) {\n            startX = r * Math.cos((2 * Math.PI * 0) / num);\n            startY = r * Math.sin((2 * Math.PI * 0) / num);\n            this.vertex.push([startX, startY]);\n            for (i = 1; i < num; i++) {\n                newX = r * Math.cos((2 * Math.PI * i) / num);\n                newY = r * Math.sin((2 * Math.PI * i) / num);\n                this.vertex.push([newX, newY]);\n            }\n        }\n        else {\n            startX = r * Math.cos((2 * Math.PI * 0) / num - Math.PI / 2);\n            startY = r * Math.sin((2 * Math.PI * 0) / num - Math.PI / 2);\n            this.vertex.push([startX, startY]);\n            for (i = 1; i < num; i++) {\n                newX = r * Math.cos((2 * Math.PI * i) / num - Math.PI / 2);\n                newY = r * Math.sin((2 * Math.PI * i) / num - Math.PI / 2);\n                this.vertex.push([newX, newY]);\n            }\n        }\n    }\n    draw() {\n        this.beginPath();\n        this.moveTo(this.vertex[0][0], this.vertex[0][1]);\n        for (let i = 1, len = this.vertex.length; i < len; i++) {\n            this.lineTo(this.vertex[i][0], this.vertex[i][1]);\n        }\n        this.closePath();\n        if (this.options.fillStyle) {\n            this.fillStyle(this.options.fillStyle);\n            this.fill();\n        }\n        if (this.options.strokeStyle) {\n            this.strokeStyle(this.options.strokeStyle);\n            if (typeof this.options.lineWidth === 'number') {\n                this.lineWidth(this.options.lineWidth);\n            }\n            this.stroke();\n        }\n    }\n}\nexports.default = EquilateralPolygon;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst shape_1 = __importDefault(require(\"./shape\"));\nclass Polygon extends shape_1.default {\n    constructor(vertex, options) {\n        super();\n        this.vertex = vertex || [];\n        this.options = options || {};\n        this.strokeColor = this.options.strokeColor;\n        this.fillColor = this.options.fillColor;\n    }\n    draw() {\n        this.clear().beginPath();\n        this.strokeStyle(this.strokeColor);\n        this.moveTo(this.vertex[0][0], this.vertex[0][1]);\n        for (let i = 1, len = this.vertex.length; i < len; i++) {\n            this.lineTo(this.vertex[i][0], this.vertex[i][1]);\n        }\n        this.closePath();\n        // 路径闭合\n        //  if (this.options.strokeStyle) {\n        //    this.strokeStyle = strokeStyle;\n        // this.lineWidth(this.options.width);\n        // this.lineJoin('round');\n        // this.stroke();\n        //  }\n        if (this.strokeColor) {\n            this.strokeStyle(this.strokeColor);\n            this.stroke();\n        }\n        if (this.fillColor) {\n            this.fillStyle(this.fillColor);\n            this.fill();\n        }\n    }\n}\nexports.default = Polygon;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst shape_1 = __importDefault(require(\"./shape\"));\nclass Rect extends shape_1.default {\n    constructor(width, height, option) {\n        super();\n        this.width = width;\n        this.height = height;\n        this.option = option || {};\n    }\n    draw() {\n        if (this.option.fillStyle) {\n            this.fillStyle(this.option.fillStyle);\n            this.fillRect(0, 0, this.width, this.height);\n        }\n        if (this.option.strokeStyle) {\n            this.strokeStyle(this.option.strokeStyle);\n            if (typeof this.option.lineWidth === 'number') {\n                this.lineWidth(this.option.lineWidth);\n            }\n            this.strokeRect(0, 0, this.width, this.height);\n        }\n    }\n}\nexports.default = Rect;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst shape_1 = __importDefault(require(\"./shape\"));\nclass RoundedRect extends shape_1.default {\n    constructor(width, height, r, option) {\n        super();\n        this.option = Object.assign({\n            lineWidth: 1,\n            lt: true,\n            rt: true,\n            lb: true,\n            rb: true\n        }, option);\n        this.r = r || 0;\n        this.width = width;\n        this.height = height;\n    }\n    draw() {\n        const width = this.width, height = this.height, r = this.r;\n        const ax = r, ay = 0, bx = width, by = 0, cx = width, cy = height, dx = 0, dy = height, ex = 0, ey = 0;\n        this.beginPath();\n        this.moveTo(ax, ay);\n        if (this.option.rt) {\n            this.arcTo(bx, by, cx, cy, r);\n        }\n        else {\n            this.lineTo(bx, by);\n        }\n        if (this.option.rb) {\n            this.arcTo(cx, cy, dx, dy, r);\n        }\n        else {\n            this.lineTo(cx, cy);\n        }\n        if (this.option.lb) {\n            this.arcTo(dx, dy, ex, ey, r);\n        }\n        else {\n            this.lineTo(dx, dy);\n        }\n        if (this.option.lt) {\n            this.arcTo(ex, ey, ax, ay, r);\n        }\n        else {\n            this.lineTo(ex, ey);\n        }\n        if (this.option.fillStyle) {\n            this.closePath();\n            this.fillStyle(this.option.fillStyle);\n            this.fill();\n        }\n        if (this.option.strokeStyle) {\n            this.lineWidth(this.option.lineWidth);\n            this.strokeStyle(this.option.strokeStyle);\n            this.stroke();\n        }\n    }\n}\nexports.default = RoundedRect;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst shape_1 = __importDefault(require(\"./shape\"));\nclass Sector extends shape_1.default {\n    constructor(r, from, to, option) {\n        super();\n        this.option = option || {};\n        this.r = r;\n        this.from = from;\n        this.to = to;\n    }\n    draw() {\n        this.beginPath()\n            .moveTo(0, 0)\n            .arc(0, 0, this.r, this.from, this.to)\n            .closePath()\n            .fillStyle(this.option.fillStyle)\n            .fill()\n            .strokeStyle(this.option.strokeStyle)\n            .lineWidth(this.option.lineWidth)\n            .stroke();\n    }\n}\nexports.default = Sector;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst graphics_1 = __importDefault(require(\"../graphics\"));\nclass Shape extends graphics_1.default {\n    draw() { }\n    render(ctx) {\n        this.clear();\n        this.draw();\n        super.render(ctx);\n    }\n}\nexports.default = Shape;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst group_1 = __importDefault(require(\"./group\"));\nconst index_1 = __importDefault(require(\"../render/index\"));\nconst event_1 = __importDefault(require(\"../event/event\"));\nclass Stage extends group_1.default {\n    constructor(container, width, height) {\n        super();\n        this.container = container;\n        this.width = width;\n        this.height = height;\n        const ctx = container.getContext('2d');\n        // @ts-ignore\n        const dpr = wx.getSystemInfoSync().pixelRatio;\n        container.width = width * dpr;\n        container.height = height * dpr;\n        ctx.scale(dpr, dpr);\n        this.dpr = dpr;\n        this.ctx = ctx;\n        this.render = new index_1.default(ctx, container.width, container.height);\n        this.hitCtx = null;\n        this.touchObject = null;\n        this.___instanceof = 'Stage';\n        this.pinchStartDistance = 0;\n        this.startPos1 = { x: 0, y: 0 };\n        this.startPos2 = { x: 0, y: 0 };\n    }\n    update() {\n        this.render.update(this);\n    }\n    setHitCanvas(hitCanvas) {\n        const hitCtx = hitCanvas.getContext('2d');\n        hitCanvas.width = this.width;\n        hitCanvas.height = this.height;\n        this.hitCtx = hitCtx;\n    }\n    getTextWidth(text, font) {\n        this.ctx.font = font;\n        return this.ctx.measureText(text).width;\n    }\n    loadImage(url) {\n        const canvas = this.container;\n        return new Promise((resolve, reject) => {\n            const image = canvas.createImage();\n            image.src = url;\n            image.onload = function () {\n                resolve(image);\n            };\n            image.onerror = function (error) {\n                reject(error);\n            };\n        });\n    }\n    touchStartHandler(evt) {\n        const p1 = evt.touches[0];\n        const touchesLength = evt.touches.length;\n        evt.stageX = Math.round(p1.x);\n        evt.stageY = Math.round(p1.y);\n        let obj = this.getObjectUnderPoint(evt);\n        this.touchObject = obj;\n        this._mouseDownX = evt.stageX;\n        this._mouseDownY = evt.stageY;\n        this.preStageX = evt.stageX;\n        this.preStageY = evt.stageY;\n        if (obj && touchesLength === 2) {\n            const p2 = evt.touches[1];\n            this.pinchStartDistance = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\n            this.startPos1 = p1;\n            this.startPos2 = p2;\n        }\n        this.__dispatchEvent(obj, evt);\n    }\n    touchMoveHandler(evt) {\n        const p1 = evt.touches[0];\n        const touchesLength = evt.touches.length;\n        evt.stageX = Math.round(p1.x);\n        evt.stageY = Math.round(p1.y);\n        let mockEvt = new event_1.default();\n        mockEvt.stageX = evt.stageX;\n        mockEvt.stageY = evt.stageY;\n        mockEvt.originalEvent = evt;\n        if (this.touchObject && touchesLength === 1) {\n            mockEvt.type = 'drag';\n            mockEvt.dx = mockEvt.stageX - this.preStageX;\n            mockEvt.dy = mockEvt.stageY - this.preStageY;\n            this.preStageX = mockEvt.stageX;\n            this.preStageY = mockEvt.stageY;\n            this.touchObject.dispatchEvent(mockEvt);\n        }\n        if (this.touchObject && touchesLength === 2) {\n            const p2 = evt.touches[1];\n            if (this.pinchStartDistance > 0) {\n                const distance = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\n                const deltaX1 = p1.x - this.startPos1.x;\n                const deltaY1 = p1.y - this.startPos1.y;\n                const deltaX2 = p2.x - this.startPos2.x;\n                const deltaY2 = p2.y - this.startPos2.y;\n                mockEvt.type = 'pinch';\n                mockEvt.zoom = parseFloat((distance / this.pinchStartDistance).toFixed(2));\n                mockEvt.dx = Math.round((deltaX1 + deltaX2) / 2);\n                mockEvt.dy = Math.round((deltaY1 + deltaY2) / 2);\n                this.pinchStartDistance = distance;\n                this.startPos1 = p1;\n                this.startPos2 = p2;\n                this.touchObject.dispatchEvent(mockEvt);\n            }\n        }\n        this.__dispatchEvent(this.touchObject, evt);\n    }\n    touchEndHandler(evt) {\n        const p1 = evt.changedTouches[0];\n        evt.stageX = Math.round(p1.x);\n        evt.stageY = Math.round(p1.y);\n        let obj = this.getObjectUnderPoint(evt);\n        this._mouseUpX = evt.stageX;\n        this._mouseUpY = evt.stageY;\n        this.__dispatchEvent(this.touchObject, evt);\n        this.touchObject = null;\n        this.preStageX = null;\n        this.preStageY = null;\n        if (obj &&\n            Math.abs(this._mouseDownX - this._mouseUpX) < 10 &&\n            Math.abs(this._mouseDownY - this._mouseUpY) < 10) {\n            let mockEvt = new event_1.default();\n            mockEvt.stageX = evt.stageX;\n            mockEvt.stageY = evt.stageY;\n            mockEvt.originalEvent = evt;\n            mockEvt.type = 'tap';\n            obj.dispatchEvent(mockEvt);\n        }\n    }\n    getObjectUnderPoint(evt) {\n        const x = evt.stageX;\n        const y = evt.stageY;\n        return this._getObjectsUnderPoint(x, y, this.hitCtx) || this;\n    }\n    __dispatchEvent(obj, evt) {\n        if (!obj)\n            return;\n        let mockEvt = new event_1.default();\n        mockEvt.stageX = evt.stageX;\n        mockEvt.stageY = evt.stageY;\n        mockEvt.originalEvent = evt;\n        mockEvt.type = evt.type;\n        obj.dispatchEvent(mockEvt);\n    }\n}\nexports.default = Stage;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst node_1 = __importDefault(require(\"./node\"));\nclass Text extends node_1.default {\n    constructor(text, option) {\n        super();\n        this.text = text;\n        option = option || {};\n        this.font = option.font || '10px sans-serif';\n        this.color = option.color || 'black';\n        this.textAlign = option.textAlign || 'left';\n        this.baseline = option.baseline || 'top';\n    }\n    render(ctx) {\n        ctx.font = this.font;\n        ctx.fillStyle = this.color;\n        ctx.textAlign = this.textAlign;\n        ctx.textBaseline = this.baseline;\n        ctx.fillText(this.text, 0, 0);\n    }\n}\nexports.default = Text;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst group_1 = __importDefault(require(\"../node/group\"));\nclass Render {\n    constructor(ctx, width, height) {\n        this.ctx = ctx;\n        this.width = width;\n        this.height = height;\n    }\n    update(stage) {\n        this.clear(this.ctx, this.width, this.height);\n        this.render(this.ctx, stage);\n    }\n    clear(ctx, width, height) {\n        ctx.clearRect(0, 0, width, height);\n    }\n    render(ctx, o) {\n        let mtx = o._props.matrix;\n        o.getMatrix(mtx);\n        if (o.children) {\n            let list = o.children.slice(0);\n            let l = list.length;\n            for (let i = 0; i < l; i++) {\n                let child = list[i];\n                if (!child.isVisible()) {\n                    continue;\n                }\n                ctx.save();\n                this._render(ctx, child, mtx);\n                ctx.restore();\n            }\n        }\n        else {\n            this._render(ctx, o, mtx);\n        }\n    }\n    _render(ctx, o, mtx) {\n        let mask = o.mask;\n        if (mtx) {\n            ctx.transform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);\n        }\n        mtx = o._props.matrix;\n        if (mask) {\n            mask.getMatrix(mtx);\n            ctx.transform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);\n            ctx.beginPath();\n            mask.render(ctx);\n            ctx.clip();\n            mtx.invert();\n            ctx.transform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);\n        }\n        o.getMatrix(mtx);\n        ctx.transform(mtx.a, mtx.b, mtx.c, mtx.d, mtx.tx, mtx.ty);\n        let props = o.getConcatenatedDisplayProps(o._props);\n        mtx = props.matrix;\n        ctx.globalAlpha *= o._props.alpha;\n        if (o.compositeOperation) {\n            ctx.globalCompositeOperation = o.compositeOperation;\n        }\n        if (o.shadow) {\n            this._applyShadow(ctx, o.shadow);\n        }\n        if (o instanceof group_1.default) {\n            let list = o.children.slice(0);\n            let l = list.length;\n            for (let i = 0; i < l; i++) {\n                ctx.save();\n                this._render(ctx, list[i]);\n                ctx.restore();\n            }\n        }\n        else {\n            o.render(ctx);\n        }\n    }\n    _applyShadow(ctx, shadow) {\n        ctx.shadowColor = shadow.color;\n        ctx.shadowOffsetX = shadow.offsetX;\n        ctx.shadowOffsetY = shadow.offsetY;\n        ctx.shadowBlur = shadow.blur;\n    }\n}\nexports.default = Render;\n","\"use strict\";\n/**\n * A doubly linked list-based Least Recently Used (LRU) cache. Will keep most\n * recently used items while discarding least recently used items when its limit\n * is reached.\n *\n * Licensed under MIT. Copyright (c) 2010 Rasmus Andersson <http://hunch.se/>\n * Typescript-ified by Oleksandr Nikitin <https://tvori.info>\n *\n * Illustration of the design:\n *\n *       entry             entry             entry             entry\n *       ______            ______            ______            ______\n *      | head |.newer => |      |.newer => |      |.newer => | tail |\n *      |  A   |          |  B   |          |  C   |          |  D   |\n *      |______| <= older.|______| <= older.|______| <= older.|______|\n *\n *  removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MakeLRUCache = void 0;\nfunction MakeLRUCache(limit) {\n    return new LRUCache(limit);\n}\nexports.MakeLRUCache = MakeLRUCache;\nfunction LRUCache(limit) {\n    // Current size of the cache. (Read-only).\n    // @ts-ignore\n    this.size = 0;\n    // Maximum number of items this cache can hold.\n    // @ts-ignore\n    this.limit = limit;\n    // @ts-ignore\n    this._keymap = {};\n}\n/**\n * Put <value> into the cache associated with <key>. Returns the entry which was\n * removed to make room for the new entry. Otherwise undefined is returned\n * (i.e. if there was enough room already).\n */\nLRUCache.prototype.put = function (key, value) {\n    var entry = { key: key, value: value };\n    // Note: No protection agains replacing, and thus orphan entries. By design.\n    this._keymap[key] = entry;\n    if (this.tail) {\n        // link previous tail to the new tail (entry)\n        this.tail.newer = entry;\n        entry.older = this.tail;\n    }\n    else {\n        // we're first in -- yay\n        this.head = entry;\n    }\n    // add new entry to the end of the linked list -- it's now the freshest entry.\n    this.tail = entry;\n    if (this.size === this.limit) {\n        // we hit the limit -- remove the head\n        return this.shift();\n    }\n    else {\n        // increase the size counter\n        this.size++;\n    }\n};\n/**\n * Purge the least recently used (oldest) entry from the cache. Returns the\n * removed entry or undefined if the cache was empty.\n *\n * If you need to perform any form of finalization of purged items, this is a\n * good place to do it. Simply override/replace this function:\n *\n *   var c = new LRUCache(123);\n *   c.shift = function() {\n *     var entry = LRUCache.prototype.shift.call(this);\n *     doSomethingWith(entry);\n *     return entry;\n *   }\n */\nLRUCache.prototype.shift = function () {\n    // todo: handle special case when limit == 1\n    var entry = this.head;\n    if (entry) {\n        if (this.head.newer) {\n            this.head = this.head.newer;\n            this.head.older = undefined;\n        }\n        else {\n            this.head = undefined;\n        }\n        // Remove last strong reference to <entry> and remove links from the purged\n        // entry being returned:\n        entry.newer = entry.older = undefined;\n        // delete is slow, but we need to do this to avoid uncontrollable growth:\n        delete this._keymap[entry.key];\n    }\n    console.log('purging ', entry.key);\n    return entry;\n};\n/**\n * Get and register recent use of <key>. Returns the value associated with <key>\n * or undefined if not in cache.\n */\nLRUCache.prototype.get = function (key, returnEntry) {\n    // First, find our cache entry\n    var entry = this._keymap[key];\n    if (entry === undefined)\n        return; // Not cached. Sorry.\n    // As <key> was found in the cache, register it as being requested recently\n    if (entry === this.tail) {\n        // Already the most recently used entry, so no need to update the list\n        return returnEntry ? entry : entry.value;\n    }\n    // HEAD--------------TAIL\n    //   <.older   .newer>\n    //  <--- add direction --\n    //   A  B  C  <D>  E\n    if (entry.newer) {\n        if (entry === this.head)\n            this.head = entry.newer;\n        entry.newer.older = entry.older; // C <-- E.\n    }\n    if (entry.older)\n        entry.older.newer = entry.newer; // C. --> E\n    entry.newer = undefined; // D --x\n    entry.older = this.tail; // D. --> E\n    if (this.tail)\n        this.tail.newer = entry; // E. <-- D\n    this.tail = entry;\n    return returnEntry ? entry : entry.value;\n};\n// ----------------------------------------------------------------------------\n// Following code is optional and can be removed without breaking the core\n// functionality.\n/**\n * Check if <key> is in the cache without registering recent use. Feasible if\n * you do not want to chage the state of the cache, but only \"peek\" at it.\n * Returns the entry associated with <key> if found, or undefined if not found.\n */\nLRUCache.prototype.find = function (key) {\n    return this._keymap[key];\n};\n/**\n * Update the value of entry with <key>. Returns the old value, or undefined if\n * entry was not in the cache.\n */\nLRUCache.prototype.set = function (key, value) {\n    var oldvalue;\n    var entry = this.get(key, true);\n    if (entry) {\n        oldvalue = entry.value;\n        entry.value = value;\n    }\n    else {\n        oldvalue = this.put(key, value);\n        if (oldvalue)\n            oldvalue = oldvalue.value;\n    }\n    return oldvalue;\n};\n/**\n * Remove entry <key> from cache and return its value. Returns undefined if not\n * found.\n */\nLRUCache.prototype.remove = function (key) {\n    var entry = this._keymap[key];\n    if (!entry)\n        return;\n    delete this._keymap[entry.key]; // need to do delete unfortunately\n    if (entry.newer && entry.older) {\n        // relink the older entry with the newer entry\n        entry.older.newer = entry.newer;\n        entry.newer.older = entry.older;\n    }\n    else if (entry.newer) {\n        // remove the link to us\n        entry.newer.older = undefined;\n        // link the newer entry to head\n        this.head = entry.newer;\n    }\n    else if (entry.older) {\n        // remove the link to us\n        entry.older.newer = undefined;\n        // link the newer entry to head\n        this.tail = entry.older;\n    }\n    else { // if(entry.older === undefined && entry.newer === undefined) {\n        this.head = this.tail = undefined;\n    }\n    this.size--;\n    return entry.value;\n};\n/** Removes all entries */\nLRUCache.prototype.removeAll = function () {\n    // This should be safe, as we never expose strong refrences to the outside\n    this.head = this.tail = undefined;\n    this.size = 0;\n    this._keymap = {};\n};\n/**\n * Return an array containing all keys of entries stored in the cache object, in\n * arbitrary order.\n */\nif (typeof Object.keys === 'function') {\n    LRUCache.prototype.keys = function () { return Object.keys(this._keymap); };\n}\nelse {\n    LRUCache.prototype.keys = function () {\n        var keys = [];\n        for (var k in this._keymap)\n            keys.push(k);\n        return keys;\n    };\n}\n/**\n * Call `fun` for each entry. Starting with the newest entry if `desc` is a true\n * value, otherwise starts with the oldest (head) enrty and moves towards the\n * tail.\n *\n * `fun` is called with 3 arguments in the context `context`:\n *   `fun.call(context, Object key, Object value, LRUCache self)`\n */\nLRUCache.prototype.forEach = function (fun, context, desc) {\n    let entry;\n    if (context === true) {\n        desc = true;\n        context = undefined;\n    }\n    else if (typeof context !== 'object')\n        context = this;\n    if (desc) {\n        entry = this.tail;\n        while (entry) {\n            fun.call(context, entry.key, entry.value, this);\n            // @ts-ignore\n            entry = entry.older;\n        }\n    }\n    else {\n        entry = this.head;\n        while (entry) {\n            fun.call(context, entry.key, entry.value, this);\n            // @ts-ignore\n            entry = entry.newer;\n        }\n    }\n};\n/** Returns a JSON (array) representation */\n//LRUCache.prototype.toJSON = function () {\n//    var s: IEntry[] = [], entry = this.head;\n//    while (entry) {\n//        s.push({ key: entry.key.toJSON(), value: entry.value.toJSON() });\n//        entry = entry.newer;\n//    }\n//    return s;\n//};\n/** Returns a String representation */\nLRUCache.prototype.toString = function () {\n    var s = '', entry = this.head;\n    while (entry) {\n        s += String(entry.key) + ':' + entry.value;\n        entry = entry.newer;\n        if (entry)\n            s += ' < ';\n    }\n    return s;\n};\n// Export ourselves\n//if (typeof this === 'object') this.LRUCache = LRUCache;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nlet UID = {\n    _nextID: 0,\n    get: function () {\n        return UID._nextID++;\n    }\n};\nexports.default = UID;\n"],"sourceRoot":""}